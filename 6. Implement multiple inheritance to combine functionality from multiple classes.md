### Guided Practice 

Let's say I am simulating some wildlife for a video game. When the player's avatar is near a lake or pond, there will be fish and ducks. 

Let's say I have two classes `Flyer` and `Swimmer`. Both accept some parameters and do some checks on the arguments. 

```python
class Flyer:  
    def fly(self, speed, altitude):  
        if speed < 0 or altitude < 0:  
            raise ValueError('speed and altitude cannot be negative')  
  
        return f"Flying at {speed} mph at {altitude} altitude!"  
    
class Swimmer:  
    def swim(self, speed, depth):  
        if depth > 0:  
            raise ValueError("Depth must be zero or negative relative to surface.")  
        return f"Swimming at {speed} mph at {depth} ft depth!"
```

Now let's say I want to extend a `Fish`. A fish does not fly but it does swim, so I only extend the `Swimmer` class to `Fish`. I add a method `glub()` so a player trying to interact with they will see the text "Glub! Glub!".  We do not need to modify the `swim()` method on `Swimmer` and we can leave it as-is. 

```python
class Fish(Swimmer):  
    def glub(self):  
        return "Glub! Glub!"

if __name__ == "__main__":    
	fish = Fish() 
    print(fish.glub())  
    print(fish.swim(7,-10))
```

But a `Duck` can both swim and fly, so we need to extend both `Swimmer` and `Flyer`.  We want to also modify the `swim()` method because ducks have to swim at 0 depth, as they cannot swim underwater like fish. Thankfully, we can re-implement the `swim()` method, check the `depth` value, and then call the `super().swim()` function after the check. 

```python
class Duck(Flyer, Swimmer):  
    def quack(self):  
        return "Quack quack!"  
  
    def swim(self, speed, depth=0):  
        if depth != 0:  
            raise ValueError("Ducks can only swim on surface at depth 0.")  
        return super().swim(speed, depth)
```

After that, we can test out the `Duck` class and see it has both `fly` and `swim` methods, because it inherits from both classes. 

```python
# Create instances  
duck = Duck()  
fish = Fish()  
  
# Demonstrate inherited methods  
print(duck.quack())  
print(duck.fly(20, 30))  
print(duck.swim(5))  
print(fish.swim(7,-10))  
  
if __name__ == "__main__":  
	print("FISH:")  
	fish = Fish()  
	print(fish.glub())  
	print(fish.swim(7,-10))  
	  
	print("DUCK")  
	duck = Duck()  
	print(duck.quack())  
	print(duck.fly(20, 30))  
	print(duck.swim(5))
```

Let's now try to look at cases with more ambiguity and how to handle it. I'm going to re-build these classes to highlight these points. Every class has an `__init__` and a `make_noise()` method. When `Duck` overrides both, what exactly happens? 

```python
class Flyer:  
    def __init__(self, max_height):  
        self.max_height = max_height  
  
    def make_noise(self):  
        return "Whoosh!"  
  
  
class Swimmer:  
    def __init__(self, depth_limit):  
        self.depth_limit = depth_limit  
  
    def make_noise(self):  
        return "Splash!"  
  
  
class Duck(Flyer, Swimmer):  
    def __init__(self, max_height, depth_limit):  
        Flyer.__init__(self, max_height)  
        Swimmer.__init__(self, depth_limit)  
  
    def make_noise(self):  
        return "Quack!"  
  
  
duck = Duck(100, 0)  
  
print(f"max_height: {duck.max_height}")  
print(f"depth_limit: {duck.depth_limit}")  
print(f"make_noise: {duck.make_noise()}")
```

To generalize these ideas, let's study how ambiguity is captured here with the `do_action()` method. B and C inherit from A, and D inherits from both B and C. Notice that it will call "In class B" because it is the left-most class, and overrides A. 


```python
class A:  
    def do_action(self):  
        print("In class A")  
  
class B(A):  
    def do_action(self):  
        print("In class B")  
  
class C(A):  
    def do_action(self):  
        print("In class C")  
  
class D(B,C):  
    def do_action(self):
	    super.do_action()
  
r = D()  
r.do_action() # prints "In class B"
```

### Try-it-yourself

Try to modify this code so that it outputs "In class D". 

```python
class A:  
    def do_action(self):  
        print("In class A")  
  
class B(A):  
    def do_action(self):  
        print("In class B")  
  
class C(A):  
    def do_action(self):  
        print("In class C")  
  
class D(A):  
    def do_action(self):  
        print("In class D")  
  
class E(B,C,D):  
    def do_action(self):  
        super().do_action()  
  
r = E()  
r.do_action() # change one line of code above so it prints "In class D"
```