### Guided Practice

**Reference:** 
https://realpython.com/python-scope-legb-rule/

The scope of a variable in Python is how your variable is visible and accessible. There are four scope levels: 
* Local
* Enclosing
* Global
* Built-in 

These are abbreviated to LEGB. 

Let's take a look at how a global scope is eclipsed by an enclosing one in a function. Recall that when we create a Python file, it is a module. Any name that exists at the top-most level of the file will be accessible anywhere in code. 

But what about functions? What happens with names inside them? What do you think this will print? 

```python
x = "global"  # Global scope  
  
def outer():  
    x = "enclosing"    
	print(x)           

outer()
print(x)
```

Now what do you think will print with this one? 

```python
x = "global"  # Global scope  
  
def outer():  
    x = "enclosing"  
    def inner():  
        x = "local"  
        print(x)      
          
    inner()  
  
outer()
```



```python
x = "global"  # Global scope

def outer():
    x = "enclosing"  # Enclosing scope
    def inner():
        x = "local"  # Local scope
        print(x)     # Resolves to local: "local"
    inner()
    print(x)         # Resolves to enclosing: "enclosing"

outer()
print(x)             # Resolves to global: "global"

# Built-in example
print(len("built-in"))  # 'len' is built-in
```

Here is a practical example. We need to create every combination of integers from x = 0 through 10, and y = 0 through 5. 

Note below how `x` and `y` are operating in many scopes here, including loops. 

```python
x = 10  
y = 5  
  
def combos(x,y):  
    combos = []  
  
    for x in range(0,x+1):  
        for y in range(0,y+1):  
            combos.append((x,y))  
  
    return combos  
  
all_combos = combos(x,y)  
  
print(all_combos)
```

Here is an annotated version: 

```python
x = 10  # Global scope  
y = 5   # Global scope  
  
def combos(x, y):  # Function parameters create local variables  
    combos = []  
  
    for x in range(0, x+1):  # Local 'x' shadows parameter 'x'  
        for y in range(0, y+1):  # Local 'y' shadows parameter 'y'  
            combos.append((x, y))  # Refers to loop variables 'x' and 'y'  
  
    return combos  
  
all_combos = combos(x, y)  # Calls function with global 'x' and 'y'  
  
print(all_combos)  # Built-in 'print' function, outputs results
```

It might be worth considering giving different names to the variables in each scope, so shadowing doesn't cause any confusion. 
```python
x = 10  
y = 5  
  
def combos(input_x, input_y):  
    collected_combos = []  
  
    for _x in range(0, input_x + 1):  
        for _y in range(0, input_y + 1):  
            collected_combos.append((_x, _y))  
  
    return collected_combos  
  
all_combos = combos(x, y)  
  
print(all_combos)
```

### Try-it-Yourself

There is a bug in this program due to the `print()` being in the wrong place. Try to fix it so every number is printed in the countdown from 10 through 0. 

```python
"""
There is a bug in this program due to the `print()` being in the wrong place. Try to fix it so every number is printed in the countdown from 10 through 0. 
"""

n = 10  
  
def countdown(n):  
    while n > 0:  
        n -= 1  
  
print(n)  
  
countdown(n)
```

Corrected:

```python
"""
There is a bug in this program due to the `print()` being in the wrong place. Try to fix it so every number is printed in the countdown from 10 through 0. 
"""

n = 10  
  
def countdown(n):  
    while n > 0:  
        n -= 1  
		print(n)  
  
countdown(n)
```

Better version: 

```python
"""  
There is a bug in this program due to the `print()`  
being in the wrong place. Try to fix it so every number  
is printed in the countdown from 10 through 0.  
"""  
  
starting_n = 10  
  
def countdown(n):  
    n+=1  
    while n > 0:  
        n -= 1  
    print(n)  
  
countdown(starting_n)
```