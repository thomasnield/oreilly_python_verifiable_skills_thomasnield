### Guided Practice

We want to send an email to a given `Contact`. 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
```

But rather than build a function outside this class to perform the email, why don't we put it in this class? It might be more convenient and make the class easier to use. 

Note how I am going to add the `send_email()` method, and I'm not actually going to set up an email connection to a server like Gmail (although I could do that), but I'll put in a placeholder `print()` to stand in for that implementation. Use the `def` keyword to define a method, just like you would a function. 

Note that I pass a parameter `self` to the function, so this gives me access  to the object's properties like `email` which I can embed into the `print` message. 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self):  
        print(f"Sending email to {self.email}")  
        print("Done!")

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
	contact.send_email()
```

But of course, I want to include a message with my email. I can set up another argument `message` that will be a string containing the message. 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self, message):  
        print(f"Sending email to {self.email}: {message}")  
        print("Done!")
  
if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
	contact.send_email("Hello! Did you receive the gift I sent you?")
```

Let's add another parameter for a priority, so we can capture what priority the email should be. We will set a default value of "Normal" for that parameter. If we do not provide it, that's what it will be. 


```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self, message, priority="Normal"):  
        print(f"Sending {priority} email to {self.email}: {message}")  
        print("Done!")

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
	contact.send_email("Hello! Did you receive the gift I sent you?", priority="High")
```

Here is an example of a method that returns a value, which merges the first name and last name to return the full name. 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self, message, priority="Normal"):  
        print(f"Sending {priority} email to {self.email}: {message}")  
        print("Done!")  
  
    def full_name(self):  
        return f"{self.first_name} {self.last_name}"  

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")    
	print(contact.full_name())
```

Now while this is perfectly valid Python, it would be lovely if we could have full_name act like an attribute or property. It would make the `Contact` class more intuitive and user-friendly. It does not require additional parameters or do any complex caclulations, so we can treat it as a derived property. This is what the `@property `decorator allows us to do. This tells Python to do some tricks under the hood so the `full_name` can be called like a property rather than a method (even though it is indeed a method still). 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self, message, priority="Normal"):  
        print(f"Sending {priority} email to {self.email}: {message}")  
        print("Done!")  
  
    @property  
    def full_name(self):  
        return f"{self.first_name} {self.last_name}"  

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
	print(contact.full_name)
```

Finally, let's look at a special method (called a "dunder" method) to change how a `Contact` object will print. 

```python
class Contact:  
    def __init__(self, first_name, last_name, email):  
        self.first_name = first_name  
        self.last_name = last_name  
        self.email = email  
  
    def send_email(self, message, priority="Normal"):  
        print(f"Sending {priority} email to {self.email}: {message}")  
        print("Done!")  
  
    @property  
    def full_name(self):  
        return f"{self.first_name} {self.last_name}"  
  
    def __str__(self):  
        return f"Name: {self.full_name}: Email: {self.email}"  

if __name__ == "__main__":  
	contact = Contact("Alice", "Smith", "alice@example.com")  
	print(contact)
```

### Try-it-Yourself

```python
class Book:  
    def __init__(self, title, author, price):  
        self.title = title  
        self.author = author  
        self.price = price  
  
    def taxed_price(self, tax_rate=.07):  
        return self.price * (1.0 + tax_rate)  
  
if __name__ == "__main__":  
	book1 = Book("The Very Hungry Caterpillar", "Eric Carle", 5.00)  
	taxed_price = book1.taxed_price(tax_rate=.05)  
	  
	print(taxed_price)
```