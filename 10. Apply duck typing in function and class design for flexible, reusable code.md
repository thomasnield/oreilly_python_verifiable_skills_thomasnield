
### Guided Practice 

Let's start with a simple class called `Duck`.

```python
class Duck:  
    def __init__(self, name):  
        self.name = name  
  
    def quack(self):  
        print("Quack!")
```

But then let's add another class called `Person`. 

```python
class Person:  
    def __init__(self, name, occupation):  
        self.name = name  
        self.occupation = occupation  
  
    def quack(self):  
        print("Ahem, Quack!")
```

I can now create a `Person` who indeed has a quack method. A human, especially an animal sound artist, can quack. 

```python
duck_imposter = Person("Carl", "Animal Sound Artist")
duck_imposter.quack()
```

This can be very flexible. For example, I can put both ducks and people in a list together and call the quack method on each of them. 

```python
ducks = [
	Duck("Webby"), 
	Person("Carl", "Animal Sound Artist")
]  
  
for duck in ducks:  
    duck.quack()
```

But now think about this: what if I only wanted Ducks in the list? I cannot expect Python to enforce that because it is a dynamically typed language and operates only on duck typing. 

Here's a practical example where I can read and write a resource.

```python
class TextFile:
    def read(self):
        return "Reading from a text file."
    def close(self):
        return "Text file closed."

class Database:
    def read(self):
        return "Reading from a database."
    def close(self):
        return "Database connection closed."

def process_resource(resource):
    print(resource.read())   # Expects a read method
    print(resource.close())  # Expects a close method

# Both work because they have read() and close() methods
text_file = TextFile()
db = Database()

process_resource(text_file)
process_resource(db)
```

While this is convenient for quick code to throw together, and the `process_resource` can handle both a `TextFile` and a `Database` since they both implement the two expected methods, there is no enforcement over other objects. 

### Try-it-yourself

Take this code below and add a third class `WebService` that is compatible with the `process_resource()` function.  

```python
class TextFile:
    def read(self):
        return "Reading from a text file."
    def close(self):
        return "Text file closed."

class Database:
    def read(self):
        return "Reading from a database."
    def close(self):
        return "Database connection closed."

def process_resource(resource):
    print(resource.read())   
    print(resource.close())  

text_file = TextFile()
db = Database()

process_resource(text_file)
process_resource(db)
```


ANSWER: 

```python
class TextFile:
    def read(self):
        return "Reading from a text file."
    def close(self):
        return "Text file closed."

class Database:
    def read(self):
        return "Reading from a database."
    def close(self):
        return "Database connection closed."

class WebService:
    def read(self):
        return "Reading from a web service."
    def close(self):
        return "Web service connection closed."
    
def process_resource(resource):
    print(resource.read())   
    print(resource.close())  

text_file = TextFile()
db = Database()
web_service = WebService()

process_resource(text_file)
process_resource(db)
process_resource(web_service)
```