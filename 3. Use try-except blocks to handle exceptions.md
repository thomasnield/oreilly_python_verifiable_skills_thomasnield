### Guided Practice

Let's get a sense of error handling in Python. Here is a simple Python program that solicits two different integers as inputs, and then divides them. It does this in a forever loop. 

```python
while True:   
    a = int(input("Please input a numerator: "))  
    b = int(input("Please input a denominator: "))  
    quotient = a / b  
  
    print(f"{a}/{b} = {quotient}")
```

But what happens if I give it a non-numeric input? Or I make the denominator 0, resulting a divide by 0? I get an error and the program crashes with a message. It should be expected that a user may have typos, or give bad inputs. 

The most basic way I can handle the error is to use a try-except block, and whenever an error occurs in that block, it will go the except block for recovery, and then allow the while loop to continue. 

```python
while True:  
    try:   
        a = int(input("Please input a numerator: "))  
        b = int(input("Please input a denominator: "))  
        quotient = a / b  
      
        print(f"{a}/{b} = {quotient}")  
  
    except Exception as e:  
        print(f"Something bad happened: {e}")
```

But here's the thing. you have. It is generally a good practice to catch errors that you plan for and target handling specific errors, and let unplanned errors escalate. . In this case, we can explicitly handle division by zero errors and numeric conversion errors. I can then handle those specific cases accordingly by checking the error type from top to bottom, and leave the broadest error type last. 

```python
while True:  
    try:  
        a = int(input("Please input a numerator: "))  
        b = int(input("Please input a denominator: "))  
        quotient = a / b  
  
        print(f"{a}/{b} = {quotient}")  
  
    except ValueError:  
        print("Error: Please enter valid integers for both numerator and denominator.")  
    except ZeroDivisionError:  
        print("Error: Division by zero is not allowed.")  
    except Exception as e:  
        print(f"An unexpected error occurred: {e}")  
        raise  # Re-raise unexpected errors to allow program to crash or escalate
```

We can also use a `finally` block that will execute, regardless if the program succeeded or failed. This is commonly used to clean up any files or connections being opened, but here we just simply print that we are done and moving onto the next loop. 

```python
while True:  
    try:  
        a = int(input("Please input a numerator: "))  
        b = int(input("Please input a denominator: "))  
        quotient = a / b  
  
        print(f"{a}/{b} = {quotient}")  
  
    except ValueError:  
        print("Error: Please enter valid integers for both numerator and denominator.")  
    except ZeroDivisionError:  
        print("Error: Division by zero is not allowed.")  
    except Exception as e:  
        print(f"An unexpected error occurred: {e}")  
        raise  # Re-raise unexpected errors to allow program to crash or escalate  
    finally:   
        print("On to the next loop!")
```

We can also raise an error at any time when we check for a custom rule that is not met. For example, we can create a function that solicits a positive integer, but it will raise an error and repeat the loop until the user provides a valid positive integer. This also shows a convenient feature of finally. We can still run a piece of code on success or failure, even if a value is returned from the function. This again can be helpful to close out connections, files, and resources. 

```python
def get_positive_integer():  
    while True:  
        try:  
            user_input = int(input("Please enter a positive integer: "))  
            if user_input <= 0:  
                raise ValueError("Input must be a positive integer.")  
            return user_input  
        except ValueError as e:  
            print(f"Invalid input: {e}. Please try again.")  
        except Exception as e:  
            print(f"Unexpected error: {e}")  
            raise  
        finally: 
	        print("Positive integer received and returned! Ending loop.")
  
# Example usage  
number = get_positive_integer()  
print(f"You entered a valid positive integer: {number}")
```


Here is another example that write 10 random integers to a text file. Note that we use `IOError` to handle any errors related to writing the data to the file. 

```python
import random  
  
filename = "numbers.txt"  
num_lines = 10  
  
try:  
    with open(filename, 'w') as file:  
        for _ in range(num_lines):  
            number = random.randint(0, 100)  # Generate random float between 0 and 100  
            file.write(f"{number}\n")  
    print(f"Generated {num_lines} random numbers in {filename}")  
except IOError:  
    print(f"Error: Could not write to file '{filename}'.")  
except Exception as e:  
    print(f"Unexpected error occurred: {e}")  
    raise  
finally:  
    print("Done.")
```

Now let's read the file and average the numbers inside of it. We will catch three specific types of errors. In the `finally` block, we will close the file. 

```python
filename = "numbers.txt"  
file = None  
  
try:  
    file = open(filename, 'r')  
    total = 0  
    count = 0  
    for line in file:  
        number = float(line.strip())  
        total += number  
        count += 1  
    average = total / count  
    print(f"Average of numbers in {filename}: {average:.2f}")  
except FileNotFoundError:  
    print(f"Error: The file '{filename}' was not found.")  
except ValueError:  
    print("Error: File contains invalid data. All lines must be numbers.")  
except ZeroDivisionError:  
    print("Error: File is empty. Cannot compute average.")  
except Exception as e:  
    print(f"Unexpected error occurred: {e}")  
    raise  
finally:  
    if file:  
        file.close()  
        print(f"File {filename} has been closed.")  
    else:  
        print("No file was opened.")
```

When you are dealing with network connections, files, or databases, it can get messy with the try-except-finally. you can streamline this using the try with resources using the `with` keyword. It will automatically handle closing the file regardless if there is an error or not. 

```python
filename = "numbers.txt"  
  
try:  
    with open(filename, 'r') as file:  
        total = 0  
        count = 0  
        for line in file:  
            number = float(line.strip())  
            total += number  
            count += 1  
        average = total / count  
        print(f"Average of numbers in {filename}: {average:.2f}")  
except FileNotFoundError:  
    print(f"Error: The file '{filename}' was not found.")  
except ValueError:  
    print("Error: File contains invalid data. All lines must be numbers.")  
except ZeroDivisionError:  
    print("Error: File is empty. Cannot compute average.")  
except Exception as e:  
    print(f"Unexpected error occurred: {e}")  
    raise  
finally:  
    print(f"File handling for {filename} completed.")
```

### Try-it-Yourself

Make a Python function that solicits a floating point value between 0 and 1 (inclusively). Have it throw appropriate errors if the user input does not follow those rules. 

```python
def get_number_between_zero_and_one():  
    while True:  
        try:  
            user_input = float(input("Please enter a number between 0 and 1: "))  
            if not 0 <= user_input <= 1:  
                raise ValueError("Input must be between 0 and 1.")  
            return user_input  
        except ValueError as e:  
            print(f"Invalid input: {e}. Please try again.")  
        except Exception as e:  
            print(f"Unexpected error: {e}")  
            raise  
        finally:  
            print("Number received and returned! Ending loop.")  
  
# Example usage  
number = get_number_between_zero_and_one()  
print(f"You entered a valid number between 0 and 1: {number}")
```